/* tslint:disable */
/* eslint-disable */
/**
 * Stockbase API
 * API for managing stock watchlists and fetching stock prices.
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: support@stockbase.xyz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration'
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios'
import globalAxios from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common'
import type { RequestArgs } from './base'
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base'

/**
 *
 * @export
 * @interface CreateWatchlist201Response
 */
export interface CreateWatchlist201Response {
  /**
   *
   * @type {number}
   * @memberof CreateWatchlist201Response
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof CreateWatchlist201Response
   */
  name?: string
  /**
   *
   * @type {Array<Stock>}
   * @memberof CreateWatchlist201Response
   */
  stocks?: Array<Stock>
}
/**
 *
 * @export
 * @interface CreateWatchlistRequest
 */
export interface CreateWatchlistRequest {
  /**
   *
   * @type {string}
   * @memberof CreateWatchlistRequest
   */
  name: string
  /**
   *
   * @type {Array<number>}
   * @memberof CreateWatchlistRequest
   */
  stockIds?: Array<number>
}
/**
 *
 * @export
 * @interface GetStockPrices200Response
 */
export interface GetStockPrices200Response {
  /**
   *
   * @type {PaginationResponseFieldsPaginationMeta}
   * @memberof GetStockPrices200Response
   */
  paginationMeta?: PaginationResponseFieldsPaginationMeta
  /**
   *
   * @type {Array<StockPrice>}
   * @memberof GetStockPrices200Response
   */
  stocks?: Array<StockPrice>
}
/**
 *
 * @export
 * @interface ListStocks200Response
 */
export interface ListStocks200Response {
  /**
   *
   * @type {PaginationResponseFieldsPaginationMeta}
   * @memberof ListStocks200Response
   */
  paginationMeta?: PaginationResponseFieldsPaginationMeta
  /**
   *
   * @type {Array<Stock>}
   * @memberof ListStocks200Response
   */
  stocks?: Array<Stock>
}
/**
 *
 * @export
 * @interface ListWatchlists200Response
 */
export interface ListWatchlists200Response {
  /**
   *
   * @type {PaginationResponseFieldsPaginationMeta}
   * @memberof ListWatchlists200Response
   */
  paginationMeta?: PaginationResponseFieldsPaginationMeta
  /**
   *
   * @type {Array<Watchlist>}
   * @memberof ListWatchlists200Response
   */
  watchlists?: Array<Watchlist>
}
/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
  /**
   *
   * @type {number}
   * @memberof LoginResponse
   */
  userId?: number
  /**
   *
   * @type {number}
   * @memberof LoginResponse
   */
  iat?: number
  /**
   *
   * @type {number}
   * @memberof LoginResponse
   */
  exp?: number
}
/**
 *
 * @export
 * @interface PaginationResponseFields
 */
export interface PaginationResponseFields {
  /**
   *
   * @type {PaginationResponseFieldsPaginationMeta}
   * @memberof PaginationResponseFields
   */
  paginationMeta?: PaginationResponseFieldsPaginationMeta
}
/**
 *
 * @export
 * @interface PaginationResponseFieldsPaginationMeta
 */
export interface PaginationResponseFieldsPaginationMeta {
  /**
   *
   * @type {number}
   * @memberof PaginationResponseFieldsPaginationMeta
   */
  totalPages?: number
  /**
   *
   * @type {number}
   * @memberof PaginationResponseFieldsPaginationMeta
   */
  totalItems?: number
  /**
   *
   * @type {number}
   * @memberof PaginationResponseFieldsPaginationMeta
   */
  limit?: number
  /**
   *
   * @type {number}
   * @memberof PaginationResponseFieldsPaginationMeta
   */
  currentPage?: number
}
/**
 *
 * @export
 * @interface SignupRequest
 */
export interface SignupRequest {
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  firstName: string
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  lastName: string
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  username: string
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  email: string
  /**
   *
   * @type {string}
   * @memberof SignupRequest
   */
  password: string
}
/**
 *
 * @export
 * @interface SimpleErrorResponse
 */
export interface SimpleErrorResponse {
  /**
   *
   * @type {string}
   * @memberof SimpleErrorResponse
   */
  message?: string
}
/**
 *
 * @export
 * @interface Stock
 */
export interface Stock {
  /**
   *
   * @type {number}
   * @memberof Stock
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Stock
   */
  symbol?: string
  /**
   *
   * @type {string}
   * @memberof Stock
   */
  companyName?: string
}
/**
 *
 * @export
 * @interface StockPrice
 */
export interface StockPrice {
  /**
   *
   * @type {number}
   * @memberof StockPrice
   */
  id?: number
  /**
   *
   * @type {number}
   * @memberof StockPrice
   */
  stockId?: number
  /**
   *
   * @type {number}
   * @memberof StockPrice
   */
  price?: number
  /**
   *
   * @type {string}
   * @memberof StockPrice
   */
  recordedAt?: string
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  username?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  firstName?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  lastName?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  email?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  oldPassword?: string
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  newPassword?: string
}
/**
 *
 * @export
 * @interface UpdateWatchlistRequest
 */
export interface UpdateWatchlistRequest {
  /**
   *
   * @type {string}
   * @memberof UpdateWatchlistRequest
   */
  name: string
}
/**
 *
 * @export
 * @interface User
 */
export interface User {
  /**
   *
   * @type {number}
   * @memberof User
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof User
   */
  username?: string
  /**
   *
   * @type {string}
   * @memberof User
   */
  email?: string
}
/**
 *
 * @export
 * @interface Watchlist
 */
export interface Watchlist {
  /**
   *
   * @type {number}
   * @memberof Watchlist
   */
  id?: number
  /**
   *
   * @type {string}
   * @memberof Watchlist
   */
  name?: string
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Authenticates a user and returns a JWT token.
     * @summary User login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login: async (
      loginRequest: LoginRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'loginRequest' is not null or undefined
      assertParamExists('login', 'loginRequest', loginRequest)
      const localVarPath = `/login`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        loginRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Logs-out the user from the current device by invalidating the current token/refreshToken pair.
     * @summary Logout current \"session\"
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/logout`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Refresh_Token required

      // authentication JWT_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Logs-out the user from all devices by invalidating all active tokens.
     * @summary Logout all devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/logoutAll`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Refresh your Access Token using the Refresh Token so you stay logged in longer.
     * @summary Refresh your Access Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/refreshToken`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Refresh_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new user account.
     * @summary User signup
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup: async (
      signupRequest: SignupRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'signupRequest' is not null or undefined
      assertParamExists('signup', 'signupRequest', signupRequest)
      const localVarPath = `/signup`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        signupRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
  return {
    /**
     * Authenticates a user and returns a JWT token.
     * @summary User login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async login(
      loginRequest: LoginRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.login']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Logs-out the user from the current device by invalidating the current token/refreshToken pair.
     * @summary Logout current \"session\"
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logout(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.logout']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Logs-out the user from all devices by invalidating all active tokens.
     * @summary Logout all devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutAll(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutAll(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.logoutAll']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Refresh your Access Token using the Refresh Token so you stay logged in longer.
     * @summary Refresh your Access Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async refreshToken(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.refreshToken']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates a new user account.
     * @summary User signup
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async signup(
      signupRequest: SignupRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.signup(signupRequest, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['AuthApi.signup']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AuthApiFp(configuration)
  return {
    /**
     * Authenticates a user and returns a JWT token.
     * @summary User login
     * @param {LoginRequest} loginRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(loginRequest: LoginRequest, options?: any): AxiosPromise<LoginResponse> {
      return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath))
    },
    /**
     * Logs-out the user from the current device by invalidating the current token/refreshToken pair.
     * @summary Logout current \"session\"
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logout(options?: any): AxiosPromise<void> {
      return localVarFp.logout(options).then((request) => request(axios, basePath))
    },
    /**
     * Logs-out the user from all devices by invalidating all active tokens.
     * @summary Logout all devices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutAll(options?: any): AxiosPromise<void> {
      return localVarFp.logoutAll(options).then((request) => request(axios, basePath))
    },
    /**
     * Refresh your Access Token using the Refresh Token so you stay logged in longer.
     * @summary Refresh your Access Token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refreshToken(options?: any): AxiosPromise<LoginResponse> {
      return localVarFp.refreshToken(options).then((request) => request(axios, basePath))
    },
    /**
     * Creates a new user account.
     * @summary User signup
     * @param {SignupRequest} signupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    signup(signupRequest: SignupRequest, options?: any): AxiosPromise<User> {
      return localVarFp.signup(signupRequest, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
  /**
   * Authenticates a user and returns a JWT token.
   * @summary User login
   * @param {LoginRequest} loginRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .login(loginRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Logs-out the user from the current device by invalidating the current token/refreshToken pair.
   * @summary Logout current \"session\"
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logout(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .logout(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Logs-out the user from all devices by invalidating all active tokens.
   * @summary Logout all devices
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public logoutAll(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .logoutAll(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Refresh your Access Token using the Refresh Token so you stay logged in longer.
   * @summary Refresh your Access Token
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public refreshToken(options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .refreshToken(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a new user account.
   * @summary User signup
   * @param {SignupRequest} signupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthApi
   */
  public signup(signupRequest: SignupRequest, options?: RawAxiosRequestConfig) {
    return AuthApiFp(this.configuration)
      .signup(signupRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StocksApi - axios parameter creator
 * @export
 */
export const StocksApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Retrieves the details of a specific stock.
     * @summary Get stock details
     * @param {number} stockId The ID of the stock to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStock: async (
      stockId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stockId' is not null or undefined
      assertParamExists('getStock', 'stockId', stockId)
      const localVarPath = `/stocks/{stockId}`.replace(
        `{${'stockId'}}`,
        encodeURIComponent(String(stockId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the price history of a specific stock.
     * @summary Get stock price history
     * @param {number} stockId The ID of the stock to retrieve price history for.
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStockPrices: async (
      stockId: number,
      limit?: number,
      page?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'stockId' is not null or undefined
      assertParamExists('getStockPrices', 'stockId', stockId)
      const localVarPath = `/stocks/{stockId}/prices`.replace(
        `{${'stockId'}}`,
        encodeURIComponent(String(stockId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves a list of all stocks.
     * @summary List all stocks
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStocks: async (
      limit?: number,
      page?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/stocks`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StocksApi - functional programming interface
 * @export
 */
export const StocksApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = StocksApiAxiosParamCreator(configuration)
  return {
    /**
     * Retrieves the details of a specific stock.
     * @summary Get stock details
     * @param {number} stockId The ID of the stock to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStock(
      stockId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Stock>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStock(stockId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StocksApi.getStock']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves the price history of a specific stock.
     * @summary Get stock price history
     * @param {number} stockId The ID of the stock to retrieve price history for.
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getStockPrices(
      stockId: number,
      limit?: number,
      page?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStockPrices200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getStockPrices(
        stockId,
        limit,
        page,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StocksApi.getStockPrices']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves a list of all stocks.
     * @summary List all stocks
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listStocks(
      limit?: number,
      page?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStocks200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listStocks(limit, page, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['StocksApi.listStocks']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * StocksApi - factory interface
 * @export
 */
export const StocksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StocksApiFp(configuration)
  return {
    /**
     * Retrieves the details of a specific stock.
     * @summary Get stock details
     * @param {number} stockId The ID of the stock to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStock(stockId: number, options?: any): AxiosPromise<Stock> {
      return localVarFp.getStock(stockId, options).then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the price history of a specific stock.
     * @summary Get stock price history
     * @param {number} stockId The ID of the stock to retrieve price history for.
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStockPrices(
      stockId: number,
      limit?: number,
      page?: number,
      options?: any
    ): AxiosPromise<GetStockPrices200Response> {
      return localVarFp
        .getStockPrices(stockId, limit, page, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves a list of all stocks.
     * @summary List all stocks
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStocks(limit?: number, page?: number, options?: any): AxiosPromise<ListStocks200Response> {
      return localVarFp.listStocks(limit, page, options).then((request) => request(axios, basePath))
    },
  }
}

/**
 * StocksApi - object-oriented interface
 * @export
 * @class StocksApi
 * @extends {BaseAPI}
 */
export class StocksApi extends BaseAPI {
  /**
   * Retrieves the details of a specific stock.
   * @summary Get stock details
   * @param {number} stockId The ID of the stock to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StocksApi
   */
  public getStock(stockId: number, options?: RawAxiosRequestConfig) {
    return StocksApiFp(this.configuration)
      .getStock(stockId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the price history of a specific stock.
   * @summary Get stock price history
   * @param {number} stockId The ID of the stock to retrieve price history for.
   * @param {number} [limit] The number of items to return.
   * @param {number} [page] The page number to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StocksApi
   */
  public getStockPrices(
    stockId: number,
    limit?: number,
    page?: number,
    options?: RawAxiosRequestConfig
  ) {
    return StocksApiFp(this.configuration)
      .getStockPrices(stockId, limit, page, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves a list of all stocks.
   * @summary List all stocks
   * @param {number} [limit] The number of items to return.
   * @param {number} [page] The page number to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StocksApi
   */
  public listStocks(limit?: number, page?: number, options?: RawAxiosRequestConfig) {
    return StocksApiFp(this.configuration)
      .listStocks(limit, page, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Deletes a specific user.
     * @summary Delete user
     * @param {number} userId The ID of the user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('deleteUser', 'userId', userId)
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the details of a specific user.
     * @summary Get user details
     * @param {number} userId The ID of the user to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('getUser', 'userId', userId)
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates the details of a specific user.
     * @summary Update user
     * @param {number} userId The ID of the user to update.
     * @param {UpdateUserRequest} updateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userId: number,
      updateUserRequest: UpdateUserRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      assertParamExists('updateUser', 'userId', userId)
      // verify required parameter 'updateUserRequest' is not null or undefined
      assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
      const localVarPath = `/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateUserRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
  return {
    /**
     * Deletes a specific user.
     * @summary Delete user
     * @param {number} userId The ID of the user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.deleteUser']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves the details of a specific user.
     * @summary Get user details
     * @param {number} userId The ID of the user to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.getUser']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates the details of a specific user.
     * @summary Update user
     * @param {number} userId The ID of the user to update.
     * @param {UpdateUserRequest} updateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userId: number,
      updateUserRequest: UpdateUserRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(
        userId,
        updateUserRequest,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['UsersApi.updateUser']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = UsersApiFp(configuration)
  return {
    /**
     * Deletes a specific user.
     * @summary Delete user
     * @param {number} userId The ID of the user to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userId: number, options?: any): AxiosPromise<void> {
      return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the details of a specific user.
     * @summary Get user details
     * @param {number} userId The ID of the user to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userId: number, options?: any): AxiosPromise<User> {
      return localVarFp.getUser(userId, options).then((request) => request(axios, basePath))
    },
    /**
     * Updates the details of a specific user.
     * @summary Update user
     * @param {number} userId The ID of the user to update.
     * @param {UpdateUserRequest} updateUserRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      userId: number,
      updateUserRequest: UpdateUserRequest,
      options?: any
    ): AxiosPromise<User> {
      return localVarFp
        .updateUser(userId, updateUserRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
  /**
   * Deletes a specific user.
   * @summary Delete user
   * @param {number} userId The ID of the user to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public deleteUser(userId: number, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .deleteUser(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the details of a specific user.
   * @summary Get user details
   * @param {number} userId The ID of the user to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public getUser(userId: number, options?: RawAxiosRequestConfig) {
    return UsersApiFp(this.configuration)
      .getUser(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates the details of a specific user.
   * @summary Update user
   * @param {number} userId The ID of the user to update.
   * @param {UpdateUserRequest} updateUserRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UsersApi
   */
  public updateUser(
    userId: number,
    updateUserRequest: UpdateUserRequest,
    options?: RawAxiosRequestConfig
  ) {
    return UsersApiFp(this.configuration)
      .updateUser(userId, updateUserRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * WatchlistsApi - axios parameter creator
 * @export
 */
export const WatchlistsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Adds an array of stocks to a specific watchlist.
     * @summary Add stocks to watchlist
     * @param {number} watchlistId The ID of the watchlist to add the stock to.
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addStocksToWatchlist: async (
      watchlistId: number,
      requestBody: Array<number>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'watchlistId' is not null or undefined
      assertParamExists('addStocksToWatchlist', 'watchlistId', watchlistId)
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('addStocksToWatchlist', 'requestBody', requestBody)
      const localVarPath = `/watchlists/{watchlistId}/stocks`.replace(
        `{${'watchlistId'}}`,
        encodeURIComponent(String(watchlistId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Creates a new watchlist for the authenticated user.
     * @summary Create a new watchlist
     * @param {CreateWatchlistRequest} createWatchlistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWatchlist: async (
      createWatchlistRequest: CreateWatchlistRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'createWatchlistRequest' is not null or undefined
      assertParamExists('createWatchlist', 'createWatchlistRequest', createWatchlistRequest)
      const localVarPath = `/watchlists`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        createWatchlistRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Deletes a specific watchlist.
     * @summary Delete watchlist
     * @param {number} watchlistId The ID of the watchlist to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWatchlist: async (
      watchlistId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'watchlistId' is not null or undefined
      assertParamExists('deleteWatchlist', 'watchlistId', watchlistId)
      const localVarPath = `/watchlists/{watchlistId}`.replace(
        `{${'watchlistId'}}`,
        encodeURIComponent(String(watchlistId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the details of a specific watchlist.
     * @summary Get watchlist details
     * @param {number} watchlistId The ID of the watchlist to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWatchlist: async (
      watchlistId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'watchlistId' is not null or undefined
      assertParamExists('getWatchlist', 'watchlistId', watchlistId)
      const localVarPath = `/watchlists/{watchlistId}`.replace(
        `{${'watchlistId'}}`,
        encodeURIComponent(String(watchlistId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves the stocks in a specific watchlist.
     * @summary List stocks in watchlist
     * @param {number} watchlistId The ID of the watchlist to retrieve stocks from.
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStocksInWatchlist: async (
      watchlistId: number,
      limit?: number,
      page?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'watchlistId' is not null or undefined
      assertParamExists('listStocksInWatchlist', 'watchlistId', watchlistId)
      const localVarPath = `/watchlists/{watchlistId}/stocks`.replace(
        `{${'watchlistId'}}`,
        encodeURIComponent(String(watchlistId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Retrieves a list of all watchlists for the authenticated user.
     * @summary List all watchlists
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWatchlists: async (
      limit?: number,
      page?: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/watchlists`
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Removes a stock from a specific watchlist.
     * @summary Remove stock from watchlist
     * @param {number} watchlistId The ID of the watchlist to remove the stock from.
     * @param {number} stockId The ID of the stock to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeStockFromWatchlist: async (
      watchlistId: number,
      stockId: number,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'watchlistId' is not null or undefined
      assertParamExists('removeStockFromWatchlist', 'watchlistId', watchlistId)
      // verify required parameter 'stockId' is not null or undefined
      assertParamExists('removeStockFromWatchlist', 'stockId', stockId)
      const localVarPath = `/watchlists/{watchlistId}/stocks/{stockId}`
        .replace(`{${'watchlistId'}}`, encodeURIComponent(String(watchlistId)))
        .replace(`{${'stockId'}}`, encodeURIComponent(String(stockId)))
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Removes multiple stocks from a specific watchlist.
     * @summary Remove multiple stocks from watchlist
     * @param {number} watchlistId The ID of the watchlist to remove the stock from.
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeStocksFromWatchlist: async (
      watchlistId: number,
      requestBody: Array<number>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'watchlistId' is not null or undefined
      assertParamExists('removeStocksFromWatchlist', 'watchlistId', watchlistId)
      // verify required parameter 'requestBody' is not null or undefined
      assertParamExists('removeStocksFromWatchlist', 'requestBody', requestBody)
      const localVarPath = `/watchlists/{watchlistId}/stocks`.replace(
        `{${'watchlistId'}}`,
        encodeURIComponent(String(watchlistId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        requestBody,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Updates the details of a specific watchlist.
     * @summary Update watchlist
     * @param {number} watchlistId The ID of the watchlist to update.
     * @param {UpdateWatchlistRequest} updateWatchlistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWatchlist: async (
      watchlistId: number,
      updateWatchlistRequest: UpdateWatchlistRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'watchlistId' is not null or undefined
      assertParamExists('updateWatchlist', 'watchlistId', watchlistId)
      // verify required parameter 'updateWatchlistRequest' is not null or undefined
      assertParamExists('updateWatchlist', 'updateWatchlistRequest', updateWatchlistRequest)
      const localVarPath = `/watchlists/{watchlistId}`.replace(
        `{${'watchlistId'}}`,
        encodeURIComponent(String(watchlistId))
      )
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      // authentication JWT_Token required

      localVarHeaderParameter['Content-Type'] = 'application/json'

      setSearchParams(localVarUrlObj, localVarQueryParameter)
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateWatchlistRequest,
        localVarRequestOptions,
        configuration
      )

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * WatchlistsApi - functional programming interface
 * @export
 */
export const WatchlistsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = WatchlistsApiAxiosParamCreator(configuration)
  return {
    /**
     * Adds an array of stocks to a specific watchlist.
     * @summary Add stocks to watchlist
     * @param {number} watchlistId The ID of the watchlist to add the stock to.
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addStocksToWatchlist(
      watchlistId: number,
      requestBody: Array<number>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Stock>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addStocksToWatchlist(
        watchlistId,
        requestBody,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.addStocksToWatchlist']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Creates a new watchlist for the authenticated user.
     * @summary Create a new watchlist
     * @param {CreateWatchlistRequest} createWatchlistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createWatchlist(
      createWatchlistRequest: CreateWatchlistRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWatchlist201Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createWatchlist(
        createWatchlistRequest,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.createWatchlist']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Deletes a specific watchlist.
     * @summary Delete watchlist
     * @param {number} watchlistId The ID of the watchlist to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteWatchlist(
      watchlistId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWatchlist(
        watchlistId,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.deleteWatchlist']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves the details of a specific watchlist.
     * @summary Get watchlist details
     * @param {number} watchlistId The ID of the watchlist to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getWatchlist(
      watchlistId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Watchlist>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchlist(watchlistId, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.getWatchlist']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves the stocks in a specific watchlist.
     * @summary List stocks in watchlist
     * @param {number} watchlistId The ID of the watchlist to retrieve stocks from.
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listStocksInWatchlist(
      watchlistId: number,
      limit?: number,
      page?: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListStocks200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listStocksInWatchlist(
        watchlistId,
        limit,
        page,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.listStocksInWatchlist']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Retrieves a list of all watchlists for the authenticated user.
     * @summary List all watchlists
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listWatchlists(
      limit?: number,
      page?: number,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListWatchlists200Response>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listWatchlists(limit, page, options)
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.listWatchlists']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Removes a stock from a specific watchlist.
     * @summary Remove stock from watchlist
     * @param {number} watchlistId The ID of the watchlist to remove the stock from.
     * @param {number} stockId The ID of the stock to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeStockFromWatchlist(
      watchlistId: number,
      stockId: number,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeStockFromWatchlist(
        watchlistId,
        stockId,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.removeStockFromWatchlist']?.[localVarOperationServerIndex]
          ?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Removes multiple stocks from a specific watchlist.
     * @summary Remove multiple stocks from watchlist
     * @param {number} watchlistId The ID of the watchlist to remove the stock from.
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeStocksFromWatchlist(
      watchlistId: number,
      requestBody: Array<number>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeStocksFromWatchlist(
        watchlistId,
        requestBody,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.removeStocksFromWatchlist']?.[
          localVarOperationServerIndex
        ]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
    /**
     * Updates the details of a specific watchlist.
     * @summary Update watchlist
     * @param {number} watchlistId The ID of the watchlist to update.
     * @param {UpdateWatchlistRequest} updateWatchlistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateWatchlist(
      watchlistId: number,
      updateWatchlistRequest: UpdateWatchlistRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Watchlist>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateWatchlist(
        watchlistId,
        updateWatchlistRequest,
        options
      )
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0
      const localVarOperationServerBasePath =
        operationServerMap['WatchlistsApi.updateWatchlist']?.[localVarOperationServerIndex]?.url
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath)
    },
  }
}

/**
 * WatchlistsApi - factory interface
 * @export
 */
export const WatchlistsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = WatchlistsApiFp(configuration)
  return {
    /**
     * Adds an array of stocks to a specific watchlist.
     * @summary Add stocks to watchlist
     * @param {number} watchlistId The ID of the watchlist to add the stock to.
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addStocksToWatchlist(
      watchlistId: number,
      requestBody: Array<number>,
      options?: any
    ): AxiosPromise<Array<Stock>> {
      return localVarFp
        .addStocksToWatchlist(watchlistId, requestBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Creates a new watchlist for the authenticated user.
     * @summary Create a new watchlist
     * @param {CreateWatchlistRequest} createWatchlistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createWatchlist(
      createWatchlistRequest: CreateWatchlistRequest,
      options?: any
    ): AxiosPromise<CreateWatchlist201Response> {
      return localVarFp
        .createWatchlist(createWatchlistRequest, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Deletes a specific watchlist.
     * @summary Delete watchlist
     * @param {number} watchlistId The ID of the watchlist to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteWatchlist(watchlistId: number, options?: any): AxiosPromise<void> {
      return localVarFp
        .deleteWatchlist(watchlistId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the details of a specific watchlist.
     * @summary Get watchlist details
     * @param {number} watchlistId The ID of the watchlist to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWatchlist(watchlistId: number, options?: any): AxiosPromise<Watchlist> {
      return localVarFp
        .getWatchlist(watchlistId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves the stocks in a specific watchlist.
     * @summary List stocks in watchlist
     * @param {number} watchlistId The ID of the watchlist to retrieve stocks from.
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listStocksInWatchlist(
      watchlistId: number,
      limit?: number,
      page?: number,
      options?: any
    ): AxiosPromise<ListStocks200Response> {
      return localVarFp
        .listStocksInWatchlist(watchlistId, limit, page, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Retrieves a list of all watchlists for the authenticated user.
     * @summary List all watchlists
     * @param {number} [limit] The number of items to return.
     * @param {number} [page] The page number to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listWatchlists(
      limit?: number,
      page?: number,
      options?: any
    ): AxiosPromise<ListWatchlists200Response> {
      return localVarFp
        .listWatchlists(limit, page, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Removes a stock from a specific watchlist.
     * @summary Remove stock from watchlist
     * @param {number} watchlistId The ID of the watchlist to remove the stock from.
     * @param {number} stockId The ID of the stock to remove.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeStockFromWatchlist(
      watchlistId: number,
      stockId: number,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removeStockFromWatchlist(watchlistId, stockId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Removes multiple stocks from a specific watchlist.
     * @summary Remove multiple stocks from watchlist
     * @param {number} watchlistId The ID of the watchlist to remove the stock from.
     * @param {Array<number>} requestBody
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeStocksFromWatchlist(
      watchlistId: number,
      requestBody: Array<number>,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removeStocksFromWatchlist(watchlistId, requestBody, options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Updates the details of a specific watchlist.
     * @summary Update watchlist
     * @param {number} watchlistId The ID of the watchlist to update.
     * @param {UpdateWatchlistRequest} updateWatchlistRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateWatchlist(
      watchlistId: number,
      updateWatchlistRequest: UpdateWatchlistRequest,
      options?: any
    ): AxiosPromise<Watchlist> {
      return localVarFp
        .updateWatchlist(watchlistId, updateWatchlistRequest, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * WatchlistsApi - object-oriented interface
 * @export
 * @class WatchlistsApi
 * @extends {BaseAPI}
 */
export class WatchlistsApi extends BaseAPI {
  /**
   * Adds an array of stocks to a specific watchlist.
   * @summary Add stocks to watchlist
   * @param {number} watchlistId The ID of the watchlist to add the stock to.
   * @param {Array<number>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public addStocksToWatchlist(
    watchlistId: number,
    requestBody: Array<number>,
    options?: RawAxiosRequestConfig
  ) {
    return WatchlistsApiFp(this.configuration)
      .addStocksToWatchlist(watchlistId, requestBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Creates a new watchlist for the authenticated user.
   * @summary Create a new watchlist
   * @param {CreateWatchlistRequest} createWatchlistRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public createWatchlist(
    createWatchlistRequest: CreateWatchlistRequest,
    options?: RawAxiosRequestConfig
  ) {
    return WatchlistsApiFp(this.configuration)
      .createWatchlist(createWatchlistRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Deletes a specific watchlist.
   * @summary Delete watchlist
   * @param {number} watchlistId The ID of the watchlist to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public deleteWatchlist(watchlistId: number, options?: RawAxiosRequestConfig) {
    return WatchlistsApiFp(this.configuration)
      .deleteWatchlist(watchlistId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the details of a specific watchlist.
   * @summary Get watchlist details
   * @param {number} watchlistId The ID of the watchlist to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public getWatchlist(watchlistId: number, options?: RawAxiosRequestConfig) {
    return WatchlistsApiFp(this.configuration)
      .getWatchlist(watchlistId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves the stocks in a specific watchlist.
   * @summary List stocks in watchlist
   * @param {number} watchlistId The ID of the watchlist to retrieve stocks from.
   * @param {number} [limit] The number of items to return.
   * @param {number} [page] The page number to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public listStocksInWatchlist(
    watchlistId: number,
    limit?: number,
    page?: number,
    options?: RawAxiosRequestConfig
  ) {
    return WatchlistsApiFp(this.configuration)
      .listStocksInWatchlist(watchlistId, limit, page, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Retrieves a list of all watchlists for the authenticated user.
   * @summary List all watchlists
   * @param {number} [limit] The number of items to return.
   * @param {number} [page] The page number to return.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public listWatchlists(limit?: number, page?: number, options?: RawAxiosRequestConfig) {
    return WatchlistsApiFp(this.configuration)
      .listWatchlists(limit, page, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Removes a stock from a specific watchlist.
   * @summary Remove stock from watchlist
   * @param {number} watchlistId The ID of the watchlist to remove the stock from.
   * @param {number} stockId The ID of the stock to remove.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public removeStockFromWatchlist(
    watchlistId: number,
    stockId: number,
    options?: RawAxiosRequestConfig
  ) {
    return WatchlistsApiFp(this.configuration)
      .removeStockFromWatchlist(watchlistId, stockId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Removes multiple stocks from a specific watchlist.
   * @summary Remove multiple stocks from watchlist
   * @param {number} watchlistId The ID of the watchlist to remove the stock from.
   * @param {Array<number>} requestBody
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public removeStocksFromWatchlist(
    watchlistId: number,
    requestBody: Array<number>,
    options?: RawAxiosRequestConfig
  ) {
    return WatchlistsApiFp(this.configuration)
      .removeStocksFromWatchlist(watchlistId, requestBody, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Updates the details of a specific watchlist.
   * @summary Update watchlist
   * @param {number} watchlistId The ID of the watchlist to update.
   * @param {UpdateWatchlistRequest} updateWatchlistRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof WatchlistsApi
   */
  public updateWatchlist(
    watchlistId: number,
    updateWatchlistRequest: UpdateWatchlistRequest,
    options?: RawAxiosRequestConfig
  ) {
    return WatchlistsApiFp(this.configuration)
      .updateWatchlist(watchlistId, updateWatchlistRequest, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
